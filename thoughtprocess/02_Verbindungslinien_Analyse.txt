# Analyse und Lösung des Verbindungslinien-Problems

## 1. Ursprüngliche Problemstellung

Bei der Entwicklung des ExplodeAssembly-Plugins für Rhino wurden zwei spezifische Anforderungen bezüglich der Verbindungslinien identifiziert:

1. Die Verbindungslinien sollten vom Explosionszentrum und nicht vom Komponentenzentrum ausgehen.
2. Es sollte eine Option geben, um die Verbindungslinien nach dem Anwenden der Explosion beizubehalten.

## 2. Problemanalyse

### 2.1 Ursprung der Verbindungslinien

Im ursprünglichen Code wurden die Verbindungslinien während der Vorschau erstellt und vom Zentrum der jeweiligen Komponente zum berechneten Endpunkt gezeichnet. Dies entsprach nicht der gewünschten Visualisierung, bei der die Linien vom zentralen Explosionspunkt ausgehen sollten.

```csharp
// Ursprünglicher Ansatz
if (_visualizeConnectionLines) 
{
    Vector3d dirVector = new Vector3d(explosionVector);
    dirVector.Unitize();
    Line directionLine = new Line(comp.Centroid, comp.Centroid + dirVector * (maxDiagonal * 0.05));
    // ...
}
```

### 2.2 Flüchtigkeit der Verbindungslinien

Die Verbindungslinien wurden als temporäre Vorschauobjekte implementiert und in der Vorschaumethode gezeichnet. Diese Objekte wurden automatisch gelöscht, wenn der Dialog geschlossen wurde, unabhängig davon, ob der Benutzer sie beibehalten wollte.

### 2.3 Sichtbarkeitsprobleme

Es gab zudem ein Problem mit der Sichtbarkeit der Linien, da:
- Die Standard-Linienstärke zu dünn war
- Die Kamera-Einstellung nicht immer optimal war, um die Linien zu sehen

## 3. Entwickelte Lösungen

### 3.1 Änderung des Linienursprungs

Die erste Änderung betraf den Ursprung der Verbindungslinien. Der Code wurde so geändert, dass ein zentrales Referenzzentrum verwendet wird:

```csharp
// Neue Implementierung
string explosionMode = _explosionModes[_explosionMode];
Point3d referenceCenter = explosionMode == "Relativ" ? _componentsCentroid : explodeCenter;

var line = new Line(referenceCenter, actualCentroid);
```

Diese Änderung erlaubt es, dass die Linien entweder vom Zentrum des Masterblocks oder vom Schwerpunkt aller Komponenten ausgehen, je nach gewähltem Explosionsmodus.

### 3.2 Persistente Verbindungslinien

Um den Erhalt der Verbindungslinien nach dem Anwenden zu ermöglichen, wurde ein mehrstufiger Ansatz entwickelt:

1. **Checkbox-Option hinzufügen**:
   ```csharp
   var keepConnectionLinesCheckBox = new CheckBox
   {
       Text = "Verbindungslinien beim Anwenden behalten",
       Checked = _keepConnectionLines
   };
   ```

2. **Sammeln der Liniendaten während des Anwendens**:
   ```csharp
   List<Line> linesToKeep = new List<Line>();
   // ...
   if (_keepConnectionLines)
   {
       foreach (var id in _newInstanceIds)
       {
           // Sammle Daten für permanente Linien
       }
   }
   ```

3. **Erstellen permanenter Linien in der Hauptdokumentation**:
   ```csharp
   if (_keepConnectionLines && linesToKeep.Count > 0)
   {
       foreach (var line in linesToKeep)
       {
           // Erstelle permanente Linien mit benutzerfreundlichen Attributen
       }
   }
   ```

### 3.3 Verbesserte Sichtbarkeit

Um die Sichtbarkeit der Linien zu verbessern, wurden mehrere Attribute geändert:

```csharp
var lineAttr = new ObjectAttributes();
lineAttr.ColorSource = ObjectColorSource.ColorFromObject;
lineAttr.ObjectColor = System.Drawing.Color.Yellow;
lineAttr.PlotWeight = 5; // Dickere Linie
lineAttr.PlotWeightSource = ObjectPlotWeightSource.PlotWeightFromObject;
lineAttr.Name = "Verbindungslinie (Explosion)"; // Benennung für einfache Identifikation
```

## 4. Erkenntnisse und Herausforderungen

### 4.1 Unterschied zwischen temporären und permanenten Objekten

Eine wichtige Erkenntnis war, dass in Rhino ein fundamentaler Unterschied zwischen temporären Vorschauobjekten und permanenten Dokumentationsobjekten besteht:

- **Temporäre Objekte** sind an den Dialog gebunden und werden automatisch entfernt, wenn der Dialog geschlossen wird.
- **Permanente Objekte** müssen explizit in der Hauptdokumentation erstellt werden, um nach dem Schließen des Dialogs erhalten zu bleiben.

Die ursprüngliche Implementierung versuchte, temporäre Objekte beizubehalten, was zum Scheitern verurteilt war.

### 4.2 Optimierung der Benutzererfahrung

Die Implementierung der Kameraanpassungsoption war ein weiterer wichtiger Schritt zur Verbesserung der Benutzererfahrung:

```csharp
// Neue Checkbox: Kamera automatisch anpassen
var autoAdjustCameraCheckBox = new CheckBox
{
    Text = "Kamera automatisch anpassen",
    Checked = _autoAdjustCamera
};
```

Diese Option erlaubt es dem Benutzer zu wählen, ob die Kamera automatisch angepasst werden soll, um alle Objekte zu zeigen, oder ob die manuelle Kameraposition beibehalten werden soll.

## 5. Fazit und Best Practices

Aus der Lösung des Verbindungslinien-Problems lassen sich folgende Best Practices ableiten:

1. **Verstehen der Plattform-Spezifika**: Die Unterscheidung zwischen temporären und permanenten Objekten in Rhino ist entscheidend.

2. **Klare visuelle Unterscheidung**: Durch Farbe, Dicke und andere Attribute werden wichtige Elemente hervorgehoben.

3. **Benutzeroptionen für Anpassbarkeit**: Durch Checkboxen und andere UI-Elemente wird die Kontrolle an den Benutzer übergeben.

4. **Namensgebung für Objekte**: Die Benennung der Linien erleichtert die spätere Identifikation und Bearbeitung.

5. **Datensammlung vor Objekterstellung**: Das Sammeln aller notwendigen Daten vor der Erstellung permanenter Objekte ist effizienter. 